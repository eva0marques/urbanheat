---
editor_options: 
  markdown: 
    wrap: 72
---

## Session setup

```{r}
library(data.table)
library(INLA)
library(ggplot2)
```

Source all functions

```{r}
source("../R/class_data_bhm.R")
source("../R/correct_altitude_gradient.R")
source("../R/run_bhm.R")
source("../R/store_post_info.R")
source("../R/evaluate_pred_vs_pro.R")
source("../R/load_palette.R")
source("../R/temperature_maps.R")
source("../R/density_plots.R")
source("../R/tile_plots.R")
source("../R/spider_charts.R")
source("../R/residual_analysis.R")
source("../R/add_sw.R")
```

## Open data

#### Observations

```{r}
car <- data.table::fread("../input/car_processed_for_bhm.csv") |>
  data_bhm(temp = "temp",
           lat = "lat",
           lon = "lon",
           time = "time",
           build_h = "H_MEAN",
           build_d = "BUILD_DENS",
           dem = "alt",
           network = "car")
cws_before_qc <- data.table::fread("../input/cws_processed_for_bhm.csv") 
cws <- cws_before_qc[which(cws_before_qc$m4), ] |>
  data_bhm(temp = "temp",
           lat = "lat",
           lon = "lon",
           time = "time",
           build_h = "H_MEAN",
           build_d = "BUILD_DENS",
           dem = "alt.y",
           network = "cws")
pro <- data.table::fread("../input/mustardijon_2018010100_2018123123.csv") |>
  data_bhm(temp = "TEMP",
           lat = "LATITUDE",
           lon = "LONGITUDE",
           time = "DATE",
           build_h = "H_MEAN",
           build_d = "BUILD_DENS",
           dem = "ALTITUDE",
           network = "mustardijon")
mustard <- read.csv("../input/mustard_metadata_stations_mustardijon_clc.csv")
mustard$lcz_100m <- as.character(mustard$LCZ_100.m)
mustard$lcz_300m <- as.character(mustard$LCZ_300.m)
mustard[mustard == "101"] <- "A"
mustard[mustard == "102"] <- "B"
mustard[mustard == "103"] <- "C"
mustard[mustard == "104"] <- "D"
mustard[mustard == "105"] <- "E"
mustard[mustard == "107"] <- "G"
mustard[mustard == "9999"] <- "9"
pro <- merge(pro,
             mustard[, c("X", "Y", "lcz_100m", "lcz_300m")],
             by.x = c("lon", "lat"),
             by.y = c("X", "Y"),
             all.y = FALSE)
```

#### Dijon borders

```{r}
borders <- sf::st_read("../input/Dijon.shp") |>
  sf::st_transform(crs = "epsg:4326") 
```

#### Prediction grid

```{r}
format_pred <- function(x, lat, lon, build_h, build_d, dem){
  x <- as.data.frame(x)
  y <- x |>
    dplyr::rename("lat" = lat) |>
    dplyr::rename("lon" = lon) |>
    dplyr::rename("build_h" = build_h) |>
    dplyr::rename("build_d" = build_d) |>
    dplyr::rename("dem" = dem)
  y <- y[, c("lat", "lon", "build_h", "build_d", "dem")]
}

pred <- data.table::fread("../input/prediction_grid_mapuce_dem.csv") |>
  format_pred("lat", "lon", "H_MEAN", "BUILD_DENS", "dem")
```

#### Radome station

```{r}
rad <- read.csv("../input/radome_2018010100_2019010100_dijonlongevic.csv")
rad$DATE <- as.POSIXct(rad$DATE, tz = "UTC")
```

## Model run for 1 timestamp

```{r}
ts <- as.POSIXct("2018-08-02 05:00:00", tz = "UTC")
sw <- rad[which(rad$DATE == ts), "GLO"]
temp_reg <- rad[which(rad$DATE == ts), "T"]
test <- run_bhm(car = car,
                cws = cws,
                pred = pred,
                ts = ts,
                sw = sw,
                temp_reg = temp_reg,
                borders = borders)
test$info <- store_post_info(test$mod_joint, test$info)
summary(test$mod_joint)
summary(test$mod_car)
summary(test$mod_cws)
eval <- evaluate_pred(test$pred, pro, info = test$info, borders)
eval 
map_pred_mean(test$pred, eval$pro, borders, "temp_sea", "car")
map_pred_mean(test$pred, eval$pro, borders, "temp_sea", "cws")
map_pred_mean(test$pred, eval$pro, borders, "temp_sea", "joint")
map_pred_sd(test$pred, borders, "joint")
map_obs(car, cws, ts = unique(test$pred$time), borders, y_var = "temp_sea")
density_obs_intercept(test$info)
density_hyperprec(test$mod_joint, test$info)
density_beta_covar(test$info)
plot_predmean_vs_ref(eval$pro, "temp_sea", "joint")
plot_res_vs_ref(eval$pro, "temp_sea", "joint")
```

## Run model on Dijon - Aug 2018

Pb at 2018082000 and 2018083100: no data?

```{r}
set.seed(12)
t_start <- as.POSIXct("2018-08-29 10:00:00", tz = "UTC")
t_end <- as.POSIXct("2018-08-31 23:00:00", tz = "UTC")
period <- seq(t_start, t_end, by = "1 hour")
for (p in period) {
  p_str <- strftime(p, format = "%Y-%m-%d %H:%M:%S", tz = "UTC") |>
    as.POSIXct(tz = "UTC")
  sw <- rad[which(rad$DATE == p_str), "GLO"]
  temp_reg <- rad[which(rad$DATE == p_str), "T"]
  inference <- run_bhm(
    car = car,
    cws = cws,
    pred = pred,
    ts = p_str,
    sw = sw,
    temp_reg = temp_reg,
    borders = borders
  )
  if (is.null(inference)) {
    next
  } else {
    saveRDS(
      object = inference$pred,
      file = paste0(
        "../output4/pred_",
        format(p_str, "%Y%m%d%H"),
        ".rds"
      )
    )
    inference$info <- store_post_info(
      inference$mod_joint,
      inference$info
    )
    eval <- evaluate_pred(inference$pred,
      pro,
      info = inference$info,
      borders
    )
    file <- "../output4/scores_201808_dijon.csv"
		write.table(eval$scores,
		            file,
		            append = TRUE,
		            sep = ",",
		            col.names = !file.exists(file),
		            row.names = FALSE,
		            quote = FALSE)
		file <- "../output4/mustard_evaluation_201808_dijon.csv"
		pro_eval <- as.data.frame(eval$pro)
		pro_eval$geometry <- NULL
		write.table(pro_eval,
		            file, 
		            append = TRUE,
		            sep = ",",
		            col.names = !file.exists(file),
		            row.names = FALSE,
		            quote = FALSE)
  }
}
```

Read scores

```{r}
out_path <- "../output4/"
scores <- read.csv(paste0(out_path, "scores_201808_dijon.csv"))
scores$time <- as.POSIXct(scores$time,
                          format = "%Y-%m-%d %H:%M:%S",
                          tz = "UTC")
pro_scores <- read.csv(paste0(out_path, "mustard_evaluation_201808_dijon.csv"))
pro_scores$time <- pro_scores$time |>
  sapply(FUN = function (x) {
    ifelse(nchar(x) == 10, paste(x, "00:00:00"), x)
    }) |>
   as.POSIXct(format = "%Y-%m-%d %H:%M:%S", tz = "UTC")

pro_scores <- add_sw(pro_scores, rad)
scores <- add_sw(scores, rad)
scores$day_night <- ifelse(scores$sw == 0, "night", "day")
```

Plot August 2018 scores

```{r}
p1 <- tiles_fixed_effect_post(scores)
p2 <- tiles_rmse(scores)
ggsave(p2,
       filename = paste0(out_path, "/tiles_rmse.png"),
       dpi = 300,
       height = 7,
       width = 16,
       bg = "white")
p3 <- tiles_int_obs_mean(scores)
ggsave(p3,
       filename = paste0(out_path, "/tiles_obs_intercepts.png"),
       dpi = 300,
       height = 7,
       width = 16,
       bg = "white")

p4 <- map_median_res_d_vs_n(pro_scores, borders)
p5 <- density_scores(pro_scores, scores)
ggsave(p5,
       filename = paste0(out_path, "/density_scores.png"),
       dpi = 300,
       height = 7,
       width = 16,
       bg = "white")
p1
p2
p3
p4
p5
```

## Plot one timestamp

```{r}
ts <- as.POSIXct("2018-08-01 12:00:00", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
pred_ts <- readRDS(
  file = paste0(
    out_path,
    "pred_",
    format(ts, "%Y%m%d%H"),
    ".rds"
  )
)
pro_scores_ts <- pro_scores[which(pro_scores$time == ts), ]
scores_ts <- scores[which(scores$time == ts), ]

sw <- rad[which(rad$DATE == p_str), "GLO"]
temp_reg <- rad[which(rad$DATE == ts), "T"]
map_pred_mean(pred_ts, pro_scores_ts, borders, model = "car")
map_pred_mean(pred_ts, pro_scores_ts, borders, model = "cws")
map_pred_mean(pred_ts, pro_scores_ts, borders, model = "joint")
map_pred_sd(pred_ts, borders, "joint")
map_obs(car, cws, ts = unique(pred_ts$time), borders)

density_obs_intercept(scores_ts)
density_beta_covar(scores_ts)
plot_predmean_vs_ref(pro_scores_ts, "temp_sea", "joint")
plot_res_vs_ref(pro_scores_ts, "temp_sea", "joint")
if (T) {
  set.seed(12)
  inference_ts <- run_bhm(
    car = car,
    cws = cws,
    pred = pred,
    ts = ts,
    sw = sw,
    temp_reg = temp_reg,
    borders = borders
  )
  density_hyperprec(inference_ts$mod_joint, scores_ts)
  inference_ts$info <- store_post_info(
    inference_ts$mod_joint,
    inference_ts$info
  )
  eval <- evaluate_pred(inference_ts$pred,
    pro,
    info = inference_ts$info,
    borders
  )
  eval$scores
}
```
